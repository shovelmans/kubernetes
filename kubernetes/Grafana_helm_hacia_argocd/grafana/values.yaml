adminUser: admin
adminPassword: admin

service:
  type: ClusterIP

ingress:
  enabled: true
  ingressClassName: nginx
  hosts:
    - grafana.local
  path: /
  pathType: Prefix
  annotations: {}
  tls: false

persistence:
  enabled: true
  existingClaim: grafana-pvc

# El chart trae un Pod de tests (templates/tests/test.yaml) pensado para "helm test".
# En ArgoCD no se ejecuta y si no existe esta clave rompe al renderizar.
testFramework:
  enabled: false

# El chart puede crear un ServiceMonitor (Prometheus Operator).
# Si no usas Prometheus Operator, déjalo desactivado para evitar el mismo error.
serviceMonitor:
  enabled: false

# Algunos templates consultan .Values.serviceAccount.create.
# Define el bloque para que no sea nil.
serviceAccount:
  create: true         # o false si quieres usar una SA existente
  name: ""             # o pon el nombre de tu SA si create=false
  annotations: {}
  labels: {}
  automountServiceAccountToken: true

# Suele ser referenciado también por los templates; mejor declararlo.
rbac:
  create: true

# El chart espera que exista el bloque 'image' porque lo usa en helpers y labels.
# Si no lo definimos, ArgoCD falla con:
# "nil pointer evaluating interface {}.tag" en templates/_helpers.tpl.
# Dejamos 'tag' vacío para que use el appVersion definido en Chart.yaml.
image:
  repository: grafana/grafana
  tag: ""                # vacío → usará appVersion del Chart.yaml (ej: 12.1.1)
  sha: ""
  pullPolicy: IfNotPresent

# El chart también consulta .Values.admin.existingSecret en templates/secret.yaml.
# Si no lo definimos, ArgoCD rompe al renderizar.
# Dejamos existingSecret vacío para que use adminUser/adminPassword definidos arriba.
admin:
  existingSecret: ""
  userKey: admin-user
  passwordKey: admin-password
